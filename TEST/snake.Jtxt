import java.util.*;



public class Globals
{
	//C++ TO JAVA CONVERTER WARNING: The following #include directive was ignored:
	//#include<bits/stdc++.h>


	public static int snakeLadder(ArrayList< ArrayList< Integer >> ladder, ArrayList< ArrayList< Integer >> snake)
	{
	  HashMap< Integer, Integer > m = new HashMap< Integer, Integer >();
	  for (ArrayList< Integer > i : ladder)
	  {
		m.put(i.get(0), i.get(1));
	  }

	  for (ArrayList< Integer > i : snake)
	  {
		m.put(i.get(0), i.get(1));
	  }

	  LinkedList< Integer > q = new LinkedList< Integer >();
	  q.offer(1);
	  int level = 1;
	  ArrayList< Boolean > vis = tangible.VectorHelper.initializedArrayList(101, 0);
	  while (!q.isEmpty())
	  {
		int size = q.size();
		while ((size--) != 0)
		{
		  int x = q.peek();
		  q.poll();
		  for (int i = 1; i < 7; i++)
		  {
			int finalpos = x + i;
			if (m.count(x + i))
			{
			  finalpos = m.get(x + i);
			}

			if (finalpos == 100)
			{
			  return level;
			}

			if (!vis.get(finalpos))
			{
			  vis.set(finalpos, 1);
			  q.offer(finalpos);
			}

		  }
		}
		++level;
	  }
	  return -1;
	}

	public static void main(String[] args)
	{
	  int s;
	  int l;
	  l = Integer.parseInt(ConsoleInput.readToWhiteSpace(true));
	  ArrayList< ArrayList< Integer >> snake = new ArrayList< ArrayList< Integer >>();
	  ArrayList< ArrayList< Integer >> ladder = new ArrayList< ArrayList< Integer >>();

	  int st;
	  int en;
	  for (int i = 0; i < l; i++)
	  {
		st = Integer.parseInt(ConsoleInput.readToWhiteSpace(true));
		en = Integer.parseInt(ConsoleInput.readToWhiteSpace(true));
		ladder.add(new ArrayList< Integer >(st, en));
	  }

	  s = Integer.parseInt(ConsoleInput.readToWhiteSpace(true));
	  for (int i = 0; i < s; i++)
	  {
		st = Integer.parseInt(ConsoleInput.readToWhiteSpace(true));
		en = Integer.parseInt(ConsoleInput.readToWhiteSpace(true));
		snake.add(new ArrayList< Integer >(st, en));
	  }

	  System.out.print(snakeLadder(snake, ladder));
	}
}

//Helper class added by C++ to Java Converter:

package tangible;

//----------------------------------------------------------------------------------------
//	Copyright © 2006 - 2022 Tangible Software Solutions, Inc.
//	This class can be used by anyone provided that the copyright notice remains intact.
//
//	This class is used to convert some of the C++ std::vector methods to Java.
//----------------------------------------------------------------------------------------
import java.util.*;

public final class VectorHelper
{
	public static <T> void resize(ArrayList<T> list, int newSize)
	{
		resize(list, newSize, null);
	}

	public static <T> void resize(ArrayList<T> list, int newSize, T value)
	{
		if (list.size() > newSize)
		{
			for (int i = list.size() - 1; i >= newSize; i--)
			{
				list.remove(i);
			}
		}
		else if (list.size() < newSize)
		{
			for (int i = list.size(); i < newSize; i++)
			{
				list.add(value);
			}
		}
	}

	public static <T> void swap(ArrayList<T> list1, ArrayList<T> list2)
	{
		ArrayList<T> temp = new ArrayList<T>(list1);
		list1.clear();
		list1.addAll(list2);
		list2.clear();
		list2.addAll(temp);
	}

	public static <T> ArrayList<T> initializedArrayList(int size, T value)
	{
		ArrayList<T> temp = new ArrayList<T>();
		for (int count = 1; count <= size; count++)
		{
			temp.add(value);
		}

		return temp;
	}

	public static <T> ArrayList<ArrayList<T>> nestedArrayList(int outerSize, int innerSize)
	{
		ArrayList<ArrayList<T>> temp = new ArrayList<ArrayList<T>>();
		for (int count = 1; count <= outerSize; count++)
		{
			temp.add(new ArrayList<T>(innerSize));
		}

		return temp;
	}

	public static <T> ArrayList<ArrayList<T>> nestedArrayList(int outerSize, int innerSize, T value)
	{
		ArrayList<ArrayList<T>> temp = new ArrayList<ArrayList<T>>();
		for (int count = 1; count <= outerSize; count++)
		{
			temp.add(initializedArrayList(innerSize, value));
		}

		return temp;
	}
}

//Helper class added by C++ to Java Converter:

package tangible;

//----------------------------------------------------------------------------------------
//	Copyright © 2006 - 2022 Tangible Software Solutions, Inc.
//	This class can be used by anyone provided that the copyright notice remains intact.
//
//	This class provides the ability to convert basic C++ 'cin' behavior.
//----------------------------------------------------------------------------------------
public final class ConsoleInput
{
	private static boolean goodLastRead = false;
	public static boolean lastReadWasGood()
	{
		return goodLastRead;
	}

	public static String readToWhiteSpace(boolean skipLeadingWhiteSpace)
	{
		String input = "";
		char nextChar;
		while (Character.isWhitespace(nextChar = (char)System.in.read()))
		{
			//accumulate leading white space if skipLeadingWhiteSpace is false:
			if (!skipLeadingWhiteSpace)
			{
				input += nextChar;
			}
		}
		//the first non white space character:
		input += nextChar;

		//accumulate characters until white space is reached:
		while (!Character.isWhitespace(nextChar = (char)System.in.read()))
		{
			input += nextChar;
		}

		goodLastRead = input.length() > 0;
		return input;
	}

	public static String scanfRead()
	{
		return scanfRead(null, -1);
	}

	public static String scanfRead(String unwantedSequence)
	{
		return scanfRead(unwantedSequence, -1);
	}

	public static String scanfRead(String unwantedSequence, int maxFieldLength)
	{
		String input = "";

		char nextChar;
		if (unwantedSequence != null)
		{
			nextChar = '\0';
			for (int charIndex = 0; charIndex < unwantedSequence.length(); charIndex++)
			{
				if (Character.isWhitespace(unwantedSequence.charAt(charIndex)))
				{
					//ignore all subsequent white space:
					while (Character.isWhitespace(nextChar = (char)System.in.read()))
					{
					}
				}
				else
				{
					//ensure each character matches the expected character in the sequence:
					nextChar = (char)System.in.read();
					if (nextChar != unwantedSequence.charAt(charIndex))
						return null;
				}
			}

			input = (new Character(nextChar)).toString();
			if (maxFieldLength == 1)
				return input;
		}

		while (!Character.isWhitespace(nextChar = (char)System.in.read()))
		{
			input += nextChar;
			if (maxFieldLength == input.length())
				return input;
		}

		return input;
	}
}
